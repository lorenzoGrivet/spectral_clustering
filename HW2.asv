clc;
clear;
close all;
format long;

% Here we open the files and we store the data in separate matrices
spiral_ds=load("Spiral.mat").X;
circle_ds=load("Circle.mat").X;



ks=[10,20,40];
for i = 1:length(ks)

    if ks(i)==10
        thresh_c=0.01;
        thresh_s=0.001;
    elseif ks(i)==20
        thresh_c=0.1;
        thresh_s=0.003;
    elseif ks(i)==40
        thresh_c=0.1;
        thresh_s=0.003;
    end

    cl_spiral=main(spiral_ds, ks(i), 20,thresh_s,"Spiral");
    cl_circle=main(circle_ds, ks(i), 20,thresh_c,"Circle");
end

if check_clusters(spiral_ds,cl_spiral)
    disp("Cluster (spiral) corretti");
else
    disp("Cluster (spiral) non corretti");
end

%%
% k_means(spiral_ds,3)
% k_means(circle_ds,3)
% 
% %%
% figure
% scatter(circle_ds(:, 1), circle_ds(:, 2), 'filled' )
% %%
% figure
% scatter(spiral_ds(:, 1), spiral_ds(:, 2), 'filled')


function clusters = main(ds, k, n_eigen,threshold, name)
    S = similarity_matrix(ds,1);  % construction of the similarity matrix
    W = knn(S, k); % using knn algorithm we compute the adjacency matrix
    D = degreeMatrix(W); % construction of the degree matrix
    L = D - W; % Laplacian matrix 
    % W, D, L matrices are stored in sparse format
    
    plot_L(L,k,name)
    
    % We only consider the eigevalues closest to 0 by setting a treshold.
    % The matrix U is then computed using their corresponding eigenvectors.

    [eigenvalues,eigenvectors]=eigen(L,n_eigen,name,k);
    
    n_clusters = nnz(eigenvalues <= threshold);
    U = eigenvectors(:, 1:n_clusters);
   
    clusters = kmeans(U, n_clusters);

    plot_clusters(ds,clusters,name,k)

    %other methods
    hierarchical_cl(ds);
    dbscan_cl(ds);
    k_means(ds,k);
end


function plot_L(L,k,name)
    figure;
    spy(L);
    title(sprintf("%s Laplacian matrix, k=%d.",name,k))
end

function plot_clusters(ds,clusters,name,k)
    % scatter plot of the dataset points with respect to the clusters
    % computed by the kmeans algrithm 
    figure;
    gscatter(ds(:,1), ds(:,2), clusters)
    legend('Cluster 1', 'Cluster 2', 'Cluster 3');
    colormap(jet);
    xlabel('X')
    ylabel('Y')
    title(sprintf('k=%d. %s dataset clusters', k,name))
end

function [eigenvalues,eigenvectors]=eigen(L,n_eigen,name,k)
    % computation of the eigenvalues and eigenvectors
    [eigenvectors, eigenvaluesMatrix] = eigs(L, n_eigen, 'smallestabs');
    figure;
    eigenvalues = diag(eigenvaluesMatrix);

    % plot of the n smallest eigenvalues,
    plot(eigenvalues, '-o', 'MarkerSize', 5, 'Color', 'b');
    xlabel('Eigenvalues');
    ylabel('Value')
    title(sprintf('k=%d. First %d eigenvalues. %s',k, n_eigen,name))
end

function hierarchical_cl(ds,k,name)
%hierarchical
    Z = linkage(ds(:,1:2), 'ward'); % Metrica di linkage
    numClusters = 3; % Numero di cluster desiderati
    clusters = cluster(Z, 'maxclust', numClusters);

    figure;
    scatter(ds(:,1), ds(:,2), 15, clusters, 'filled');
    title('Hierarchical Clustering');
    xlabel('X');
    ylabel('Y');
end

function dbscan_cl(ds,k,name)
    %dbscan
    epsilon = 0.05; % distanza massima tra punti per considerarli vicini
    minPts = 3;    % numero minimo di punti richiesti per formare un cluster
    [labels, ~] = dbscan(ds(:,1:2), epsilon, minPts);
    
    figure;
    scatter(ds(:,1), ds(:,2), 15, labels, 'filled');
    title(sprintf('DBSCAN Clustering, %s data-set. k = %d',k,name));
    xlabel('X');
    ylabel('Y');
end




function m = similarity_matrix(ds,sigma)
    [r,~]=size(ds);
    m=zeros(r,r);   
    for i=1:r
        for j=i:r
            
            if i==j
                m(i,j)=0;
            else
                v=f_sim(ds(i,1:2),ds(j,1:2),sigma);
                if v > 1e-7  % threshold set to take into account only 
                             % the points with significative distance
                    m(i,j)=v;
                    m(j,i)=v;
                end 
            end
        end
    end

end



function s = f_sim(x1,x2,sigma)
    s=exp(-norm(x1 - x2)^2 / (2 * sigma^2));
end


function W = knn(S, k)
    [m,n] = size(S);
    M = zeros(m,n);
    
    for i = 1 : m
        [~, sortedIndices] = sort(S(i, :), 'descend');
        sortedIndices = sortedIndices(1 : k);
        for j = 1 : length(sortedIndices)
            M(i,sortedIndices(j)) = S(i,sortedIndices(j));
            M(sortedIndices(j), i) = S(i,sortedIndices(j));
        end

    end
    

    %Elements added to make the matrix simmetrycal
    disp(nnz(M) - 10*m)

    if M == M'
        W = sparse(M);
    end
end


function D = degreeMatrix(W)
    degrees = sum(W, 2); 
    D = spdiags(degrees, 0, size(W, 1), size(W, 1));
end

function b=check_clusters(ds,cl)

    %check if clusters we found are the same of the ones in the third
    %column of the file spiral.mat indipendentemente of the order
    %********************************************************************* 
    %******************************************************************************
    [m,n] =size(ds);
    e=1;
    f=1;
    if n>2
        l=ds(:,3);
        c1=[];
        c2=[];
        
        for i=2:m
            if l(i)==l(i-1)
                c1=[c1,e];
            else
                e=e+1;
                c1=[c1,e];
            end

            if cl(i)==cl(i-1)
                c2=[c2,f];
            else
                e=e+1;
                c2=[c2,f];
            end
        end

        b=norm(c1-c2,2);
        

    end
end


function k_means(ds,k,name)
    ds=ds(:,1:2);
    [idx, C] = kmeans(ds, k);
    
    figure;
    gscatter(ds(:,1), ds(:,2), idx);
    hold on;
    plot(C(:,1), C(:,2), 'kx', 'MarkerSize', 15, 'LineWidth', 3);
    legend('Cluster 1', 'Cluster 2', 'Cluster 3', 'Centroids');
    title(sprintf('Clustering k-means, %d data set',name));
    hold off;
end





